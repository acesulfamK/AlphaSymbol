# StrictPrfGameの内部仕様

# 概要

StrictPrfGameとは、形式的な文法StrictPrf(以後Prfと略す)を書き換え、テストケースを満たす語を作るゲームである。

# ゲームの説明

## 大まかな流れ

用語
- 初期語
- 入力数列
- 出力数列


ユーザは初めにPrfの初期語`Z()`とテストケースとして2つの数列(入力数列と出力数列)を与えられる。
ゲームが始まると、ユーザは与えられた語を書き換えていき、入力数列の各要素を入力したとき、出力数列の各要素を返す関数を表せたらゲーム終了であり、1ポイントを獲得する。

一方、100手以内に正解の語にたどり着けなかった場合、ゲーム失敗となり、ポイントは獲得できない。

## 書き換え操作のルール

1回の書き換え操作は、書き換えを行う場所を表す自然数列と、書き換え後を表すトークンに対応した語(`S()`, `Z()`, `P(i, j)`, `C(Z())`, `C(Z(), Z())`, `C(Z(), Z(), Z())`, ..., `R(Z(), Z())`) の組で`([1, 1, 2], "p_3")`のように表される。

場所を表す自然数列の表し方を説明する。目的の部分Prfを、一番外側の関数から「第a引数の、さらに第b引数の、さらに第c引数の...」というように辿って表し、このときの引数の番号をつなげて`a, b, c..`というように表す。

例えば、`C(Z(), R(S(), P(1, 1)), S())`の、`P(1, 1)`を書き換えたい場合、これは`C`の2番目の引数`R`の2番目の引数なので、この場所は`[2, 2]`と表される。ちなみに、ここで`[2]`と指定すると、`R(S(), P(1, 1))`の全てが消去され、新し語に書き変わる

次に、書き換え後の語の種類について説明する。ゲームには予めMAX_P_ARITY, EXPR_DEPTH, MAX_C_ARGS という3つの数が決まっており、ゲーム中には変わらない。この数を使って、以下のように書き換え後の語の種類が決まる。 
- z: `Z()`
- s: `S()`
- p_i_j: `P(i, j)` (ただし、MAX_P_ARITY >= i >= j)
- c_i: `C(Z(), Z(), Z(), ..., Z())` (ただし、引数の数iはMAX_C_ARGSを超えない)
- r: `R(Z(), Z())`

### 書き換え操作の例

ゲーム内の値が以下のように決まっており、
```
MAX_P_ARITY = 2
EXPR_DEPTH = 2
MAX_C_ARGS = 2
```
現在のユーザの語が`C(Z(), R(S(), P(1, 1)), S())`のときにできる操作を考えてみる。

書き換え場所は以下のよう。
- 1
- 2, 1
- 2, 2
- 3
書き換え先の語は以下のよう
- z
- s
- p_1_1
- p_2_1
- p_2_2
- c_1
- c_2
- r
よって、8x3で24通りの操作が行えることになる。


## 探索範囲の上限
MAX_P_ARITY: 探索における射影作用素Pのarityの最大
EXPR_DEPTH: 探索における式の構造の深さの最大
MAX_C_ARGS: 探索におけるCの取る引数の数 (C(X1, X2, ..., Xn)のn)



